// See LICENSE.SiFive for license details.

package freechips.rocketchip

import chisel3.internal.sourceinfo.{SourceInfo, SourceLine, UnlocatableSourceInfo}
import chisel3.Data
import freechips.rocketchip.config.Parameters
import scala.language.implicitConversions


/**
  * Diplomacy is a set of abstractions for describing directed, acyclic graphs
  * where parameters will be negotiated between nodes. These abstractions are
  * expressed in the form of abstract classes, traits, and type parameters, which
  * comprises nearly all of the types defined in this file.
  *
  * The [[NodeImp]] ("node implementation") is the main abstract type that determines
  * the type parameters of all other abstract types. Defining a concrete
  * implementation of [[NodeImp]] will therefore determine concrete types for all
  * type parameters. For example, passing in a concrete instance of NodeImp to a
  * SourceNode will fully determine concrete types for all of a SourceNode's type
  * parameters.
  *
  * Specific applications of Diplomacy are expected to either extend these types
  * or to specify concrete types for the type parameters. This allows for
  * creating and associating application-specific node, edge, parameter, and bundle types.
  *
  * It is key to understand that the edge parameters can be abstract concept -- it carries any sort of conceptual
  * information that is useful to pass along the graph edge. For example, the full address map visible from
  * a given edge including the supported access types for each memory region.
  * In contrast, the bundle parameter carries information used to parameterize the hardware bundle type (for
  * example, signal widths).
  *
  *
  * Concepts, metaphors, and mnemonics to help with understanding Diplomacy code.
  *
  * Diplomacy has some implicit acronym described below:
  *   Parameters System:
  *   D[IO], U[IO], E[IO], B[IO] are parameters which will be propagated.
  *   D: Downwards (master -> slave)
  *   U: Upwards (slave -> master)
  *   E: Edge contains necessary nearby nodes connection information.
  *   B: Bundle should extends from [[chisel3.Data]].
  *
  * # General Phase
  *
  * It contains such phases:
  *   1. Node binding(non-lazy)
  *     `nodeB := nodeA` is a typical node binding in diplomacy.
  *     It binds `nodeA` as master [[OutwardNode]] with `nodeB` as slave [[InwardNode]] together.
  *     When executing `nodeB := nodeA`, `nodeB` will invoke [[InwardNode.bind]], which is implemented in [[MixedNode.bind]]:
  *       `nodeA` will call `nodeA.oPush(index, node, binding)`, in [[OutwardNode.oPush]]:
  *         `index` is current `nodeA` [[OutwardNode.accPO]] size, which represents the how many [[InwardNode]] has been binded to `nodeA`.
  *         `node` is [[NodeHandle]] of `NodeB`,
  *         `binding` is the binding type, which is used for deciding port mapping behavior.
  *       Similarly, `nodeB`, will call [[InwardNode.iPush]] after `nodeA` finish its binding.
  *   2. Port mapping(lazy)
  *     Port mapping converts [[OutwardNode.accPO]] and [[InwardNode.accPI]] to [[MixedNode.oPortMapping]] and [[MixedNode.iPortMapping]]
  *     it use [[MixedNode.resolveStar]], solves the size of each connection,
  *     after solving node binding will be converted to port.
  *   3. Parameter negotiation(lazy)
  *     After finishing port mapping,
  *     [[MixedNode.doParams]] and [[MixedNode.uiParams]] are results of parameter negotiation,
  *   4. Bundle building.(lazy)
  *     After finishing parameter propagation,
  *     [[MixedNode.edges]] can be generated by zipping ports and parameters together.
  *
  * # Anatomy of a Node:
  *
  * Graph below represents the variable and function usage in the diplomacy flow.
  * → means target variable/function is generated by source.
  * ─ means source use the function to generate another target.
  *
  *                                                                                                             (from the other node)
  *                                                  ┌──────────────────────────────────────────────────────────[[MixedNode.uiParams]]─────────────┐
  *                                                  ↓                                                                                             │
  *   (binding node when elaboration)     [[MixedNode.uoParams]]────────────────────────[[MixedNode.mapParamsU]]→──────────┐                       │
  *      [[InwardNode.accPI]]                                                                      │                       │                       │
  *                  │                                                                             │            (based on protocol)                │
  *                  │                                                                             │            [[MixedNode.inner.edgeI]]          │
  *                  │                                                                             │                       ↓                       │
  *                  ↓                                                                             │                       │                       │
  * (immobilize after elaboration)   (inward port from [[OutwardNode]])                            │                       ↓                       │
  *      [[InwardNode.iBindings]]──┐     [[MixedNode.iDirectPorts]]────────────────────→[[MixedNode.iPorts]]    [[MixedNode.uiParams]]             │
  *                  │             │                ↑                                              │                       │                       │
  *                  │             │                │                                   [[MixedNode.doParams]]             │                       │
  *                  │             │                │                                   (from the other node)              │                       │
  *                  │             │                │                                              │                       │                       │
  *                  │             │                │                                              │                       │                       │
  *                  │             │                │                                              └────────┬──────────────┤                       │
  *                  │             │                │                                                       │              │                       │
  *                  │             │                │                                                       │   (based on protocol)                │
  *                  │             │                │                                                       │   [[MixedNode.inner.edgeI]]          │
  *                  │             │                │                                                       │              │                       │
  *                  │             │     (from the other node)                                              │              ↓                       │
  *                  │             └────[[MixedNode.oPortMapping]]     [[MixedNode.oStar]]                  │   [[MixedNode.edgesIn]]───┐          │
  *                  │                              ↑                             ↑                         │              │            ↓          │
  *                  │                              │                             │                         │              │ [[MixedNode.in]]      │
  *                  │                              │                             │                         │              ↓            ↑          │
  *                  │   (solve star connection)    │                             │                         │   [[MixedNode.bundleIn]]──┘          │
  *                  ├───[[MixedNode.resolveStar]]→─┼─────────────────────────────┤                         └────────────────────────────────────┐ │
  *                  │                              │                             │                             [[MixedNode.bundleOut]]─┐        │ │
  *                  │                              │                             │                                        ↑            ↓        │ │
  *                  │                              │                             │                                        │ [[MixedNode.out]]   │ │
  *                  │                              ↓                             ↓                                        │            ↑        │ │
  *                  │            ┌──────[[MixedNode.iPortMapping]]    [[MixedNode.iStar]]                      [[MixedNode.edgesOut]]──┘        │ │
  *                  │            │       (from the other node)                                                            ↑                     │ │
  *                  │            │                 │                                                                      │                     │ │
  *                  │            │                 │                                                           [[MixedNode.outer.edgeO]]        │ │
  *                  │            │                 │                                                           (based on protocol)              │ │
  *                  │            │                 │                                                                      │                     │ │
  *                  │            │                 │                             ┌────────────────────────────────────────┤                     │ │
  *                  │            │                 │                             │                                        │                     │ │
  *                  │            │                 │                             │                                        │                     │ │
  *                  │            │                 │                             │                                        │                     │ │
  * (immobilize after elaboration)│                 ↓                             │                                        │                     │ │
  *     [[OutwardNode.oBindings]]─┘      [[MixedNode.oDirectPorts]]───→[[MixedNode.oPorts]]                     [[MixedNode.doParams]]           │ │
  *                  ↑               (inward port from [[OutwardNode]])           │                                        │                     │ │
  *                  │                  ┌─────────────────────────────────────────┤                                        │                     │ │
  *                  │                  │                                         │                                        │                     │ │
  *                  │                  │                                         │                                        │                     │ │
  *     [[OutwardNode.accPO]]           │                                         ↓                                        │                     │ │
  *   (binding node when elaboration)   │ [[MixedNode.diParams]]──────→[[MixedNode.mapParamsD]]────────────────────────────┘                     │ │
  *                                     │            ↑                                                                                           │ │
  *                                     │            └───────────────────────────────────────────────────────────────────────────────────────────┘ │
  *                                     └──────────────────────────────────────────────────────────────────────────────────────────────────────────┘
  *
  * # Inward/Outward vs. Upward/Downward
  *
  * Diplomacy defines two dimensions: inward/outward and upward/downward.
  *
  * Inward/outward refer to the direction of the directed graph itself. For a
  * given node:
  * - Inward refers to edges that point into a node.
  * - Outward refers to edges that point out of a node.
  *
  * A useful mnemonic for distinguishing between inward and outward is to always
  * view it from the perspective of a particular node. Because Diplomacy
  * describes directed, acyclic graphs, this direction will always be consistent
  * across the entire graph.
  *
  * Upward/downward refer to the direction of the parameter negotiation, where
  * the direction is relative to the inward/outward direction. For a given edge:
  * - Upward refers to a flow of parameters in the outward direction.
  * - Downward refers to a flow of parameters in the inward direction.
  *
  * A useful mnemonic for distinguishing between upward and downward is to imagine
  * the diplomatic graph as a literal network of rivers where upward refers to
  * parameters that move in the upstream direction while downward refers to
  * parameters that move in the downstream direction.
  *
  *
  *                                                              DO from those nodes
  *
  *                                                 [[OutwardNode.doParams(l)]]
  *                                                 ↓
  *               [[InwardNode.uiParams(n)]]        DO   [[OutwardNode.doParams(m)]]
  *                           .                     ↓    ↓
  *         DI from this node .                     ↓    DO   [[OutwardNode.doParams(m)]]
  *                           .                     ↓    ↓    ↓
  *               [[InwardNode.uiParams(0)]]        ↓    ↓    DO
  *                                        ↑        ↓    ↓    ↓ DO from that node
  *      ┌─────────────────────────────────↑────────↓────↓────↓[[MixedNode.iPorts]]┐
  *      │                                 ↑  │  *──*────*────* │ DI as this node  │
  *      │             ┌───────────────────↑──│──↓──────────────┘                  │
  *      │             ↓                   ↑  │  ↓                                 │
  *      │  [[MixedNode.edgesIn]]          ↑  │  Seq[DI]                           │
  *      │             ↑                   ↑  │  ↓                                 │
  *      │     ┌───────│───────────────────↑──│──↓───────────────────────────┐     │
  *      │     │       │                   ↑  │  ↓                           │     │
  *      │     │     [[InwardNode.uiParams]]  │  ↓                           │     │
  *      │     │                           ↑  │  [[InwardNode.diParams]]     │     │
  *      │     │                     Seq[UI]  │  ↓                           │     │
  *      │     │                           ↑  │  ↓                           │     │
  *      │     └──────[[InwardNodeImp.mixI]]──│──↓───────────────────────────┘     │
  *      │                                 ↑  │  ↓                                 │
  *      │                                 ↑  │  Seq[DO]                           │
  *      │                           Seq[UI]  │  ↓                                 │
  *      │                                 ↑  │  ↓                                 │
  *      │     ┌────[[MixedNode.mapParamsU]]──│──[[OutwardNodeImp.mixO]]─────┐     │
  *      │     │                           ↑  │  ↓                           │     │
  *      │     │                           ↑  │  Seq[DO]                     │     │
  *      │     │    [[OutwardNode.uoParams]]  │  ↓                           │     │
  *      │     │                           ↑  │  [[OutwardNode.doParams]]    │     │
  *      │     │                           ↑  │  ↓                    │      │     │
  *      │     └───────────────────────────↑──│──↓────────────────────│──────┘     │
  *      │                                 ↑  │  ↓                    ↓            │
  *      │                           Seq[UO]  │  ↓         [[MixedNode.edgesOut]]  │
  *      │                                 ↑  │  ↓                    ↑            │
  *      │                  ┌──────────────↑──│──↓────────────────────┘            │
  *      │  UO as this node │ *────*────*──*  │  ↓                                 │
  *      └[[MixedNode.oPorts]]↑────↑────↑─────│──↓─────────────────────────────────┘
  *         UI from that node ↑    ↑    ↑     │  ↓
  *                           UI   ↑    ↑     │  [[OutwardNode.doParams(n)]]
  *                           ↑    ↑    ↑     │               .
  *     [[InwardNode.uiParams(i)]] UI   ↑     │               . DO from this node
  *                                ↑    ↑     │               .
  *          [[InwardNode.uiParams(j)]] UI    │  [[OutwardNode.doParams(0)]]
  *                                     ↑     │
  *               [[InwardNode.uiParams(k)]]  │
  *                                           │
  *         DO from those nodes               │
  *                                           │
  *
  * # Handles
  *
  * Two Diplomatic nodes can be bound together using the := operator or one of
  * its sibling operators. Binding is asymmetric, and the binding operation will
  * connect the outer side of one node to the inner side of the other.
  *
  * For example, the expression a := b will connect the outer side of b to the
  * inner side of a.
  *
  * We would like the := operator to have additional properties that make it
  * intuitive to use:
  *
  * 1. It should be chainable, so that a := b := c will have the intuitive effect
  *    of binding c to b and b to a. This requires that the return type of := be the
  *    same as its arguments, because the result of one := operation must be
  *    valid as an argument to other := operation.
  *
  * 2. It should be associative, so that (a := b) := c is equivalent to a := (b
  *    := c). This means that the order in which the bind operations execute does
  *    not matter, even if split across multiple files.
  *
  * 3. a := b should only be allowed if and only if b allows outward edges and a
  *    allows inward edges. This should be preserved even when chaining
  *    operations, and it should ideally be enforced at compile time.
  *
  * Handles are a way of satisfying all of these properties. A Handle represents
  * the aggregation of a chain of Nodes, and it preserves information about
  * the connectability of the innermost and the outermost sides of the chain.
  *
  * If b supports inward edges, then a := b returns a Handle that supports inward
  * edges that go into b. If a supports outward edges, then a := b returns a
  * Handle that supports outward edges coming out of a.
  */

package object diplomacy
{
  type SimpleNodeHandle[D, U, E, B <: Chisel.Data] = NodeHandle[D, U, E, B, D, U, E, B]

  def sourceLine(sourceInfo: SourceInfo, prefix: String = " (", suffix: String = ")") = sourceInfo match {
    case SourceLine(filename, line, col) => s"$prefix$filename:$line:$col$suffix"
    case _ => ""
  }

  def bitIndexes(x: BigInt, tail: Seq[Int] = Nil): Seq[Int] = {
    require (x >= 0)
    if (x == 0) {
      tail.reverse
    } else {
      val lowest = x.lowestSetBit
      bitIndexes(x.clearBit(lowest), lowest +: tail)
    }
  }

  implicit class BigIntHexContext(val sc: StringContext) extends AnyVal {
    def x(args: Any*): BigInt = {
      val orig = sc.s(args: _*)
      BigInt(orig.replace("_", ""), 16)
    }
  }

  type PropertyOption = Option[(String, Seq[ResourceValue])]
  type PropertyMap = Iterable[(String, Seq[ResourceValue])]

  implicit class IntToProperty(x: Int) {
    def asProperty: Seq[ResourceValue] = Seq(ResourceInt(BigInt(x)))
  }

  implicit class BigIntToProperty(x: BigInt) {
    def asProperty: Seq[ResourceValue] = Seq(ResourceInt(x))
  }

  implicit class StringToProperty(x: String) {
    def asProperty: Seq[ResourceValue] = Seq(ResourceString(x))
  }

  implicit class DeviceToProperty(x: Device) {
    def asProperty: Seq[ResourceValue] = Seq(ResourceReference(x.label))
  }

  def EnableMonitors[T](body: Parameters => T)(implicit p: Parameters) = body(p.alterPartial {
    case MonitorsEnabled => true
  })
  def DisableMonitors[T](body: Parameters => T)(implicit p: Parameters) = body(p.alterPartial {
    case MonitorsEnabled => false
  })
  def FlipRendering[T](body: Parameters => T)(implicit p: Parameters) = body(p.alterPartial {
    case RenderFlipped => !p(RenderFlipped)
  })

  implicit def moduleValue[T](value: ModuleValue[T]): T = value.getWrappedValue

  implicit def noCrossing(value: NoCrossing.type): ClockCrossingType = SynchronousCrossing(BufferParams.none)

  type BundleBridgeInwardNode[T <: Data] = InwardNodeHandle[BundleBridgeParams[T], BundleBridgeParams[T], BundleBridgeEdgeParams[T], T]
  type BundleBridgeOutwardNode[T <: Data] = OutwardNodeHandle[BundleBridgeParams[T], BundleBridgeParams[T], BundleBridgeEdgeParams[T], T]
  type BundleBridgeNode[T <: Data] = NodeHandle[BundleBridgeParams[T], BundleBridgeParams[T], BundleBridgeEdgeParams[T], T, BundleBridgeParams[T], BundleBridgeParams[T], BundleBridgeEdgeParams[T], T]
}
